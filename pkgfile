#!/bin/bash

###
# pkgfile -- search the arch repo to see what package owns a file
# This program is a part of pkgtools

# Copyright (C) 2008 Daenyth <Daenyth+Arch _AT_ gmail _DOT_ com>
# 
# Pkgtools is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# Pkgtools is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
##

###
# You can change these values in the config file
##
PKGTOOLS_DIR='/usr/share/pkgtools/'
FILELIST_DIR="$PKGTOOLS_DIR/lists"
MIRROR_DIR="$PKGTOOLS_DIR/mirrors"
RATELIMIT='100k' # Argument to wget's --limit-rate flag
PACMAN_CONF='/etc/pacman.conf'
PACMAN_MIRRORLIST='/etc/pacman.d/mirrorlist'
PACPARSER="$PKGTOOLS_DIR/pacparser.pl"

if [ -r /usr/share/pkgtools/functions ]; then
        source /usr/share/pkgtools/functions
else
        printf "Unable to source function file!\n" >&2
        exit 1
fi

###
# You should not change below this point
##
VERBOSE=0
DEBUG=0
REMOTE_SEARCH=0 # Force remote search instead of using pacman database
BINARIES=0 # Search for binaries (files in a bin or sbin directory). 
STATIC_REPOS=0 # Don't use pacparser, but use the old static repo stuff instead
UPDATE=0
REPOS=(core extra community)


if [ -r /etc/pkgtools/pkgfile.conf ]; then
        source /etc/pkgtools/pkgfile.conf
fi
if [ -r "${HOME}/.pkgtools/pkgfile.conf" ]; then
        source "${HOME}/.pkgtools/pkgfile.conf"
fi
readonly MYVERSION=6.1
SEARCHTARGET=
ACTIONS=()
PROGNAME="$(basename $0)"

umask 0022 # This will ensure that any files we create are readable by normal users

# not() -- toggle a 0/1 {{{
not () {
        if [ "$1" -eq 0 ]; then
                echo 1
        else
                echo 0
        fi
}
# }}}

# cd_filelist_dir() {{{
cd_filelist_dir () {
        cd "$FILELIST_DIR" || die 1 "Unable to change directory to %s\n" $FILELIST_DIR
        if [ 'noempty' == "$1" ]; then
                if echo * | grep -q '^\*$'; then
                        die 1 "%s appears to be empty! Did you run %s --update?\n" "$FILELIST_DIR" "$PROGNAME"
                fi
        fi
}
# }}}

# usage() {{{
usage () {

#           |--------------------------------------------------------------------------------| 80 Characters
        msg "%s version %s -- Find which package owns a file\n" "$PROGNAME" $MYVERSION
        msg "Usage: %s [ACTIONS] [OPTIONS] filename\n" "$PROGNAME"
        msg "ACTIONS:\n"
        msg "  -h --help       - Print this help.\n"
        msg "  -i --info       - Provides information about the package owning a file.\n"
        msg "                    Similar to \`rpm -Qf'.\n"  
        msg "  -l --list       - List files similar to \`pacman -Ql'.\n"
        msg "  -r --regex      - Search for a regex instead of a filename.\n"
        msg "  -s --search     - Search for what package owns a file.\n"
        msg "                    This is the default action.\n"
        msg "  -u --update     - Update to the latest filelist.\n"
        msg "                    This requires write permission for\n"
        msg "                    %s\n" $FILELIST_DIR

        msg "OPTIONS:\n"
        msg "  -b --binaries   - When using --list, only show files in a bin/ directory.\n"
        msg "  -d --debug      - Increase debug level. This can be passed multiple times.\n"
        msg "  -L --limit-rate - Limit wget's data transfer rate when using --update.\n"
        msg "  -R --remote     - Search remotely instead of using local pacman info.\n"
        msg "  -v --verbose    - Enable verbose output.\n"
#           |--------------------------------------------------------------------------------| 80 Characters
        quit ${1:-0}
}
# }}}

# update() -- update the package file list {{{
update () {
        for repo in ${REPOS[@]}; do
                [ "$DEBUG" -eq 1 ] && set -x
                eval mirror="$(grep -v '^ *#' $PACMAN_MIRRORLIST | grep -v '^ *$' | head -n 1 | cut -d ' ' -f 3)"
                repofile="${repo}.files.tar.gz"
                filelist="${mirror}/${repofile}"

                if [ ! -d "$FILELIST_DIR" ]; then
                        warn "%s does not exist -- creating " $FILELIST_DIR
                        mkdir -p "$FILELIST_DIR" || die 1 "Could not create %s\n" $FILELIST_DIR
                fi
                if [ ! -w "$FILELIST_DIR" ];then
                        die 1 "No write permission to %s, try somewhere else\n" "$FILELIST_DIR"
                fi
                cd_filelist_dir
                rm -f "$repofile"
                if [ "$VERBOSE" -eq 1 ]; then
                        msg "Using mirror %s... " $mirror
                fi
                msg "Updating %s file list... " $repo
                wget -q  --limit-rate="$RATELIMIT" "$filelist" || (warn "Could not retrieve %s\n" $filelist; continue)
                msg "Extracting file list... " $repo
                mkdir -p "$repo.tmp" || (warn "Could not create directory for %s\n" $repo; continue)
                tar zxf "$repofile" -C "$repo.tmp" 2> /dev/null || (warn "Unable to extract %s\n" $repofile; continue)
                rm -rf "$repo"
                mv "$repo.tmp" "$repo"
                rm -f "$repofile"
                msg "Done\n"
                [ "$DEBUG" -eq 1 ] && set +x
        done
        quit 0

}
# }}}

# search() -- find which package owns a file {{{
search () {
        [ "$DEBUG" -eq 1 ] && set -x
        if [ 'regex' = "$action" ]; then
                local fname="$1"
        else
                local fname="$(echo $1 | sed 's|^/|^|; s|^\([^^]\)|/\1|')$"; shift
                # Change a leading / to ^.
                # Change a leading non-^ character to '/$char;
                # This will fix grep's regex to prevent false positives
        fi
        [ "$DEBUG" -eq 1 ] && echo "'$fname'"

        cd_filelist_dir noempty

        if [ "$VERBOSE" -eq 0 ]; then
                local sedstring='s#-[0-9.a-z_]*-[0-9.]*/files:.*##'
        else
                local sedstring='s#-[0-9.a-z_]*-[0-9.]*/files:# : /#' 
        fi

        [ "$DEBUG" -eq 1 ] && set +x # The grep line gets to be rather.. long
        grep -R "$fname" */* | sed "$sedstring" | uniq

        [ "$DEBUG" -eq 1 ] && set -x
        quit 0
}
# }}}

# listfiles() {{{
listfiles () {
        local pkg="$1"
        local FOUNDFILE=0

        if [ $REMOTE_SEARCH -eq 0 ]; then
                if pacman -Q "$pkg" &> /dev/null; then
                        if [ $BINARIES -eq 0 ]; then
                                pacman -Ql "$pkg"
                        else
                                pacman -Ql "$pkg" | grep -E '/s?bin/.'
                        fi
                        return 0
                fi
        fi

        cd_filelist_dir noempty
        for repo in ${REPOS[@]}; do
                [ "$DEBUG" -eq 1 ] && set -x
                local findarg="$repo/$pkg-[^-]+-[^-]+$"
                local findresult="$(\
                        find "$repo" -type d -regex "$findarg" | while read line; do
                                filelist="$line/files"
                                sed -n "1d;s|^|$pkg /|p" "$filelist" | sort # Give it output like pacman -Ql
                        done)"
                if [ -n "$findresult" ]; then
                        FOUNDFILE=1
                        if [ $BINARIES -eq 0 ]; then
                                echo "$findresult"
                        else
                                echo "$findresult" | grep -E '/s?bin/.'
                        fi

                fi
                [ "$DEBUG" -eq 1 ] && set +x
        done
        if [ "$FOUNDFILE" -eq 0 ]; then
                msg "Package '%s' not found\n" "$pkg"
                return 1
        fi
        return 0
}
# }}}

# pkgquery() -- similar to rpm -Qf {{{
pkgquery () {
        local fname="$1"
        local LOCALFILE=0
        
        # If the file is local we can take some shortcuts to improve speed.
        [ -e "$fname" ] && LOCALFILE=1
        # Should add a "which" test to also see if it's local, when using -b

        if [ $LOCALFILE -eq 1 -a $REMOTE_SEARCH -eq 0 ]; then
                local pkgname=$(LC_ALL=C pacman -Qo "$fname" 2>&1)
                if [[ "$pkgname" =~ 'error: ' ]]; then
                        die 1 'Unable to find package info for file %s\n' "$fname"
                fi
                pkgname=$(echo $pkgname | cut -d ' ' -f 5)
                pacman -Qi "$pkgname"
        else
                die 1 '%s --info may currently only be used with local files\n' $PROGNAME
        fi

}
# }}}

# generate_mirror_list() -- make a list of mirrors for repos, so that we can support more than default {{{
generate_mirror_list () {
        perl "$PACPARSER" "$MIRROR_DIR" "$PACMAN_CONF"
        case $? in
                127) die 1 "%s requires perl. If you don't want custom repo handling,\nset STATIC_REPOS=1 in your pkgfile.conf" $PACPARSER ;;
                *) return $?
        esac
}
# }}}

if [ -z "$1" ]; then
        usage
fi

while [ $# -gt 0 ]; do
        case "$1" in
                -b|--binaries)
                        BINARIES=$(not $BINARIES)
                        ;;
                -d|--debug)
                        DEBUG=$(( DEBUG += 1 ))
                        ;;
                -h|--help)
                        usage
                        ;;
                -i|--info)
                        ACTIONS=(${ACTIONS[@]} info)
                        ;;
                -L|--limit-rate)
                        [ -z "$2" ] && die 1 "%s %s option requires an argument!\n" "$PROGNAME" "$1"
                        RATELIMIT="$2"; shift
                        ;;
                -l|--list)
                        ACTIONS=(${ACTIONS[@]} list)
                        ;;
                -R|--remote)
                        REMOTE_SEARCH=$(not $REMOTE_SEARCH)
                        ;;
                -r|--regex)
                        ACTIONS=(${ACTIONS[@]} regex)
                        ;;
                -s|--search)
                        ACTIONS=(${ACTIONS[@]} search)
                        ;;
                -u|--update)
                        UPDATE=$(( UPDATE += 1 ))
                        ;;
                -v|--verbose)
                        VERBOSE=$(not $VERBOSE)
                        ;;
                -*)
                        die 1 "Unrecognized option %s\n" "$1"
                        ;;
                *)
                        [ -z "${ACTIONS[@]}" ] && ACTIONS=(${ACTIONS[@]} search)
                        SEARCHTARGET="$1"
                        ;;
        esac
        shift
done

if [ $UPDATE -ge 1 ]; then
#        if [ $UPDATE -ge 2 ]; then
#                update force # This will be used when I check timestamps. Analogous to pacman -Syy
#        else
                update
#        fi
fi

if [ -z "$SEARCHTARGET" ]; then
        die 1 "No package name specified to search for!\n"
fi

# I'm gonna change this back to one action per invocation, this is complicated and mostly pointless.
for action in "${ACTIONS[@]}"; do
        case $action in
                search|regex)
                        search "$SEARCHTARGET"
                        ;;
                list)
                        listfiles "$SEARCHTARGET"
                        ;;
                info)
                        pkgquery "$SEARCHTARGET"
                        ;;
                *)
                        die 1 "Invalid \$ACTIONS item '%s' -- This should never happen!\n" "$action"
                        ;;
        esac
done

quit 0
# vim: set ts=8 fdm=marker et :
